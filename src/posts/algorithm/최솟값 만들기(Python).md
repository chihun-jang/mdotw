---
title: "#34 알고리즘 연습 - 최솟값 만들기(Python)"
date: "2019-05-20"
category: ['algorithm']
draft : False
---



길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 
배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다.

이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다.

이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. 
(단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)

예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면

A에서 첫번째 숫자인 1, B에서 두번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)

A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)

A에서 세번째 숫자인 2, B에서 첫번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)

즉, 이 경우가 최소가 되므로 29를 return 합니다.

배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.



제한사항

* 배열 A, B의 크기 : 1000 이하의 자연수
* 배열 A, B의 원소의 크기 : 1000 이하의 자연수


입출력 예

|A|	B|	answer|
|-|-|-|
|[1, 4, 2]|	[5, 4, 4]|	29|
|[1,2]|	[3,4]|	10|


입출력 예 설명

입출력 예 #1
문제의 예시와 같습니다.

입출력 예 #2
A에서 첫번째 숫자인 1, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 4) 다음, A에서 두번째 숫자인 2, B에서 첫번째 숫자인 3을 뽑아 곱하여 더합니다. (누적된 값 : 4 + 6 = 10)
이 경우가 최소이므로 10을 return 합니다.


>__*문제풀이*__   
위와 같은 방법으로 최솟값을 찾는데에는 무작위를 통해 최솟값을 찾는게 아닌 어떤 규칙하에 움직일 거라 생각했다.
그리고 가장 간단하게 [1,2,3], [1,2,3]이라는 2개의 list를 비교해 보았을때
1*1 + 2*2 + 3*3 보다 1*3 + 2*2 + 3*1 으로
A리스트의 최소 * B리스트의 최대 .... 이런식으로 연산을 수행하는게 훨씬더 최솟값을 가지는 것을 발견했다.




#### 내 풀이 🏆
```python
def solution(A, B):       

    answer = 0                 #답을 더해 나가기 위한 변수
    A.sort()                   #A를 오름차순으로 정렬한다
    B.sort(reverse=True)       #B를 내림차순으로 정렬한다.
    for i in range(len(A)):    #두 list의 길이가 같으므로 한 list의 길이만큼만 반복하며
        answer += A[i] * B[i]  #answer에 A의 최솟값과 B의 최댓값을 곱한 결과를 더한다.
    return answer
```

#### 다른 풀이 🏆
```python
def getMinSum(A, B):

    return sum(a*b for a, b in zip(sorted(A), sorted(B, reverse=True)))

    #zip함수는 크기가 같은 iterable한(셀수있는) 애들을 하나로 묶어주는 역할을 한다

    #따라서 위의 코드 같은 경우 [1,2,3],[3,2,1]이 있을때 [(1,3),(2,2),(3,3)] 이런식으로 결과를 리턴해주고

    #a와 b는 각각 1,3 / 2,2 를 돌면서 값을 연산한다음 그 값들을 더해준다.

    #이때 sum안에 들어가는 객체는 generator 클래스이다.
print(getMinSum([1, 2], [3, 4]))
```