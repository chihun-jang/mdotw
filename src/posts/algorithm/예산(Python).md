---
title: '#31 알고리즘 연습 - 예산(Python & JS)'
date: '2019-05-07'
category: ['algorithm']
draft: False
---

S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다.
그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다.
그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.

물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다.
예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며,
1,000원보다 적은 금액을 지원해 줄 수는 없습니다.

부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때,
최대 몇 개의 부서에 물품을 지원해 줄 수 있는지 return 하도록 solution 함수를 완성해주세요.

제한사항

-   d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.

-   d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
-   budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.
-   물품을 구매해 줄 수 있는 부서 개수의 최댓값을 return 하세요.

입출력 예

| d           | budget | result |
| ----------- | ------ | ------ |
| [1,3,2,5,4] | 9      | 3      |
| [2,2,3,3]   | 10     | 4      |

입출력 예 설명

입출력 예 #1
각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면
예산 9원에서 7원이 소비되어 2원이 남습니다.
항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다.
위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

-   1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
-   1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
-   1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
-   1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.

3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

입출력 예 #2
모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.

> **_문제풀이_**  
> 뭔가 입력받는 d 배열도 순서가 없고 어떻게 최적의 예산분배를 해주지 라는 생각에 잠시 겁을 먹었지만  
> 생각을 해보니 가장 많은 부서에 분배를 해주기 위해서는 예산을 적게 요구한 부서부터 분배가 이루어지면 되므로  
> sort와 sum값을 사용해주면 쉽게 해결 될거라 생각했다.

#### 내 풀이 🏆

```python
def solution(d, budget):
    want_budget = 0
    #sum이라는 내장함수가 있기에 조금더 이런 네이밍을 함
    cnt = 0
    #몇개의 부서가 혜택을 받을 수 있는지 세는 변수

    for i in sorted(d):
    #i가 b를 .sort를 이용해서 정렬하지 않고 sorted를 이용해
    #정렬한 값을 list로 return해주고 사용해줌
        if want_budget + i > budget:
        # 부서가 원하는 예산을 미리 더해서 예산을 초과하면
            break
            # break를 통해서 for문을 빠져나온다
        want_budget += i
        # if문으로 검사해서 이상없으면 계속 부서들이 원하는 예산을 더하고

        cnt += 1
        # 부서의 숫자도 계속 count해 나간다.
    return cnt

```

#### 다른 풀이 🏆

```python
def solution(d, budget):
    d.sort()
    while budget < sum(d):
    #sum을 이용해서 부서들의 요구 예산을 다 더하고
        d.pop()
    #초과될경우 pop으로 계속 큰 애들부터 퇴출시켜나가는데
    return len(d)
    #이렇게 될경우 while과 sum으로 인해 시간 복잡도가 많이 걸릴수 잇어
    #짧아보이지만 좋은 코드는 아닌것 같다.더해서 나가는게 훨씬 나은 듯

```

---

#### 나의 풀이(JS)🏆

```javascript
function solution(d, budget) {
    var answer = 0;
    var want_budget = 0;
    d.sort((a, b) => a - b);
    d.map(item => {
        want_budget += item;
        if (want_budget <= budget) {
            answer += 1;
        }
    });
    return answer;
}
```

JS로 풀때 신경써야할 부분은 sort가 default문자열 정렬이라는 것,
그리고 이번에 사용하면서 알게 되었는데**_ map과 foreach는 break를 이용해서 멈출수 없다는 것이다._**
따라서 map이나 foreach를 사용하게 되면 반복문을 중간에 빠져나오기 위해 return과 같은 trick을 사용해주던데, 나는 조건을 조금 바꿔서 반복은 전체 길이만큼 하되 조건에 맞을때만 연산이 가능하도록 작성해주었다.

#### 다른 풀이(JS)🏆

```javascript
function solution(d, budget) {
    var answer = 0;
    var index = 0;
    d.sort((a, b) => a - b);

    while (answer + d[index] <= budget) {
        answer += d[index];
        index++;
    }
    return index;
}
```

위의 코드는 아예 while의 조건으로 예산 조건을 넣어줘 반복문을 똑똑하게 사용해준 예이다.

아직 JS에서의 `while`, 그리고 `++`에 대해서 익숙하지 않은데 항상 유념해둬야겠다.

> 그리고 다른 풀이 중에 ~라는 연산자가 있는데, 이는 bitwise연산자중 Not에 해당하는 것으로 피연산자의 반전된 값을 반환해준다. 하지만 사용이 까다로울 것 같아서 따로 풀이를 가져오지는 않았다.

### 프로그래머스 Lv1 을 다풀다

드디어 프로그래머스의 코딩테스트 연습 lv 1을 다 풀었다.

그렇게 많은 문제는 아니였지만 java와 python으로 시작했다가 python에 좀더 집중하기위해 중간에 java는 중지하고 python을 풀어왔는데

나름 내가 푼 코드와 다른 사람들의 코드를 비교하며 어느 것이 더 나을까 고민해보고
무슨 문법을 사용하고 메서드, 함수를 썼는지 고민하다보니

문제를 풀기위해 생각을 이끌어 나가는게 훨씬 다양한 방향으로 넓게 생각할 수 있게 된것같다.

그럼 lv2 에서도 좀 더 진일보한 모습을 기대하며

lv 1 끝-
