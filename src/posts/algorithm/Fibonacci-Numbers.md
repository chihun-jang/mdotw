---
title: "#32 알고리즘 연습 - Fibonacci numbers(Python)"
date: "2019-05-14"
category: ['Algorithm']
draft : False
---


피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.

예를들어

* F(2) = F(0) + F(1) = 0 + 1 = 1
* F(3) = F(1) + F(2) = 1 + 1 = 2
* F(4) = F(2) + F(3) = 1 + 2 = 3
* F(5) = F(3) + F(4) = 2 + 3 = 5
와 같이 이어집니다.

2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.


제한 사항

* n은 1이상, 100000이하인 자연수입니다.


입출력 예

|n|	return|
|3|	2|
|5|	5|


입출력 예 설명

피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, ... 와 같이 이어집니다.


>__*문제풀이*__   
일단 문제에서 제시해준것처럼
F(2) = F(0) + F(1) = 0 + 1 = 1 의 방법을 떠올리면 제일 먼저   
Recursive function으로 구현을 하면 어떨까라는 생각이 들었다.
구현은 쉽게 구현이 되는 반면 조금만 넘어가도 런타임 에러가 발생하는 것을 알 수 있었다.   
그래서 재귀함수가 아닌 다른 방법이 없을까 고민하던 와중에   
list를 쌓아가며 sum을 이용하여 계산해 주면 어떨까라고 생각을 했다.


#### 내 풀이 🏆
```python
def solution(n):
    anslist = [0,1]      
    #n이 2 이상 입력되므로 시드 값으로 list에 0과 1을 입력해 놓는다
    for i in range(n-1): 
    #range(n-1)까지로 범위제한을 해줬으므로 실제로 for문이 돌아가는 횟수는 n-1번이다

    #즉 n = 2일때 1번의 for문이 돌아 
    #list의 마지막에 F(2)가 추가되고 n= 10이면 9번 돌아 
    #list안에는 11개의 원소 F(0)~ F(10)까지를 가지게 되는 것이다.

        anslist.append(sum(anslist[-2:]))    
        #anslist에서 마지막 2개를 가져와서 sum을 해주면 피보나치수가 되고 그 값을 list마지막에 추가
    return anslist[-1]%1234567               
    #문제에서 피보나치 수를 1234567로 나눈 나머지를 반환하라 했으므로

    #list의 마지막수 %1234567을 해준 값을 리턴해주도록 한다

```
리스트에서 특정 index로 접근하는 것은 시간 복잡도가 O(n)이므로 재귀함수를 사용해서 연산을 해줄 때보다 훨씬 빠른 코드를 작성할 수 있다.


#### 다른 풀이 🏆(1234567로 나눈 나머지 제외조건)
```python
def fibonacci(num):
    a,b = 0,1              #a는 F(0)의 값 b는 F(1)의 값을 각각 대입해줬다.
    for i in range(num):   #i 는 입력받은 만큼 for문을 돌며 a 와 b값을 연산해줌
        a,b = b,a+b        #num으로 2를 입력받으면 a와 b에는 각각 F(2) 와 F(3)가 들어가있음
    return a               # 따라서 우리가 입력받은 num의 피보나치 수를 찾기 위해서는 a값을 return해줘야함
```


### 느낀점
 
#### Recursive가 만능이 아니다.
만약 피보나치 수열을 Recursive로 구현하게 된다면

F(5) ==> F(4) + F(3) == F(3) + F(2) + F(2) + F(1) == F(2) + F(1) + F(1) + F(0) + F(1) +F(0) +F(1)
== F(1) + F(0) + F(1) + F(1) + F(0) + F(1) + F(0) + F(1)   ==> 7번 덧셈

즉 2^n-2 -1 만큼의 연산이 이루어 지게 된다

따라서 시간복잡도는 2^n만큼 되게 되는데 이렇게 되면 n 이 조금만 증가해도 시간복잡도가 급격하게 증가하여 연산속도의 저하를 가져온다.
