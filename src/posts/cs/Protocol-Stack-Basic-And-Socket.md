---
title: "Protocol Stack의 시작과 socket"
date: "2019-02-06"
category: ['Network','CS']
draft : False
---

### ⚡ Protocol Stack의 시작과 socket


*프로토콜 스택*

TCP/IP의 데이터를 전기신호로 만들어 보낸다
네트워크 제어용 소프트웨어를 프로토콜 스택이라고 한다

**브라우저가 건내준 메세지를 패킷에 저장하고 수신주소 등의 제어정보를 덧붙여 오류가 발생할시 패킷의 수정 및 통신의 기본을 조절하는 역할**

프로토콜 스택이 **패킷을 LAN 어댑터**(이더넷,무선 LAN으로 통신할때 쓰는 하드웨어)에 
넘기면 **LAN어댑터가 전기신호로 변환**하여 전송


>💡💡    
1. 지금 사용하고 있는 이더넷은 국제표준에 적합하지 않다
이더넷 헤더(패킷의 맨앞에 제어정보)는 표준 이전사양을 따른다. 
국제 표준의 헤더길이가 길어 효율이 안좋기 때문이다.   
2. TCP/IP는 하나의 프로토콜이였는데 후에 둘로 나뉘었다.    
3. 패킷을 사용하는 통신기술은 1960년대 컴퓨터의 데이터 통신을 위해 고안.
이를 통해 기존의 전화회선을 연결하여 연결된 상대와의 통신만 가능했던 불편함을 극복하였다.





### 데이터 송신의 구조

```
네트워크 애플리케이션(브라우저, 메일러, 웹서버, 메일서버 등)

⬇️⬇️⬇️

Socket 라이브러리 ( 리졸버를 통해 DNS서버 조회)

⬇️⬇️⬇️

OS내부( TCP(Transmission Control Protocol) 과 UDP(User Datagram Protocol) 
브라우저나 메일 등 일반적 앱은 TCP를 사용하여 데이터 송수신, 
DNS서버조회등 짧은 제어용 데이터 송수신은 UDP)

⬇️⬇️⬇️

OS내부(IP(Internet Protocol)프로토콜 : 패킷 송수신을 제어하는 부분, 패킷을 통신상대까지 운반)
패킷 : 분할된 데이터의 덩어리

    IP내부 (ICMP(Internet Control Message Protocol), ARP(Address Resolution Protocol)) 
                
    ICMP : 패킷을 운반할때 발생하는 오류를 통지하거나 제어용 메세지 통지
    ARP(아프) : IP주소에 대응하는 이더넷(수신처 라우터)의 MAC 주소를 조사할때 사용

    MAC 주소 : LAN 방식의 기기가 사용하는 같은 형식의 주소(훗날 재설명)

⬇️⬇️⬇️

LAN 드라이버 : LAN어댑터의 하드웨어 제어, 
LAN 어댑터가 실제 송, 수신 동작, 즉 케이블에 대해 신호를 송수신
```

순서는 바뀔 수 있으므로 흐름을 생각해주자




### 소켓

*소켓의 실체는 통신제어용 제어정보*

프로토콜 스택은 내부에 제어정보를 기록하는 *메모리*를 가지고 있는데
통신상대의 *IP주소, 포트번호, 통신동작의 진행상태(응답여부, 경과시간 등) 를 기록*한다.

그리고 이를 소켓이라 생각하면 된다
```shell 

netstat -ano 라는 명령어를 통해 윈도우의 소켓을 화면에 표시할 수 있다.
                    
a : 통신중인것 뿐만 아니라 통신개시전의 것도 포함하여 표시
n : IP주소나 포트번호를 번호로 표시
o : 소켓을 사용하고 잇는 프로그램의 PID(process ID 프로그램 식별을 위해 OS가 할당) 

```
참고사항 : 

* UDP 프로토콜은 소켓을 상대 주소나 포트에 연결 하지 않으므로 *:*표시 
* `state - LISTENING` : 상대의 접속을 기다림 
* `ESTABLISHED` : 접속동작이 끝나고 데이터가 통신중인지 나타냄
* IP주소가 `0.0.0.0` 이라는 것은 통신 시작 전이라 IP주소가 정해지지 않은것
* 복수의 LAN 어댑터를 장착하는 서버에서 접속동작을 특정 LAN어댑터에만 하고싶을때 
기다리는 소켓이라도 IP주소를 할당해주면 된다.



### Socket (라이브러리)을 호출했을때 프로토콜 스택의 동작 

DNS조회하는 리졸버를 사용하는 부분에서 UDP프로토콜을 사용하여 프로토콜 스택이 동작
그 이후의 애플리케이션의 동작에 대해서는 TCP 부분에서 담당

`<디스크립터> = socket(<IPv4 사용>, <TCP 사용>, ... )` socket을 호출

위의 명령어에 따라 프로토콜 스택은 한개의 소켓을 만드는데
이때 제어정보를 기록할 메모리영역을 확보(OS 메모리 관리 모듈이용)하고 초기상태의 제어정보를 기록

*소켓이 만들어지면 디스크립터를 애플리케이션에 알려주고* 
애플리케이션이 이후에 데이터 송수신을 프토토콜 스택에 의뢰할때 
*디스크립터를 알려주면 소켓 내에 기록된 통신 관련 정보를 프로토콜 스택*은 바로 알수 있다.

