---
title: "데이터 송수신 종료"
date: "2019-04-02"
category: ['Network','CS']
draft : False
---

### ❌데이터 송수신의 종료

데이터 송수신이 끝나게 되면 종료하게 되는데

이는 리퀘스트와 응답메세지가 오고가는게 끝나거나
(응답후에도 리퀘스트가 갈 수있는 경우) 리퀘스트 메세지가 없을때 클라이언트가 연결끊기 돌입

애플리케이션에따라 다르므로 프로토콜스택은 어느쪽에서 먼저 끊어도 상관없게 구성되어있다


***

연결을 끊는 측(여기서는 서버라 가정)의 애플리케이션

1. Socket 라이브러리의 `close`를 호출하고
 
2. 서버측의 프로토콜 스택이 TCP헤더를 만들어 연결끊기 정보(**컨트롤 비트 FIN비트에 1설정**, IP에 의뢰) 설정, 서버측의 소켓에 연결끊기에 대한 정보 기록

***

끊기는 측 (클라이언트) 

3. 수신된 TCP헤더를 통해 자신의 소켓이 연결끊기에 대해 기록

4. 잘 받았다는 것을 알리기 위해 **ACK번호**를 반송
   그리고 `read`를 호출하여 데이터를 읽으려 하는데
   서버의 데이터 수신이 완료되면 클라이언트도 종료에 돌입

5. **FIN 비트를 1로 설정**하여 서버에 송신 (2와 동일)

***

끊는 측 (서버측)

6. FIN비트에 대해 응답으로 ACK번호 반송 (4와 동일)

***


### 소켓의 말소

대화가 끝나면 소켓을 이용해 통신할수 없는데 에러를 막기위해 잠시 기다렸다가 말소

예를 들어
클라이언트에서 연결끊기가 먼저 실행되면
서버는 마지막으로 클라이언트가 보낸 ACK번호를 수신 못 할때 다시 FIN를 보낼수 있다.
그런데 클라이언트의 소켓이 말소되면 제어정보가 사라지게 되고
더더욱이 다른 애플리케이션에 의해 다른 소켓이 이전에 사용하던 포트번호가 할당될수도 있다. 
그럼 **다른 소켓으로 FIN이 들어가게되고 다른 소켓이 말소되는 경우가 발생**할 수 있다.

이때 소켓 말소를 기다리는 시간은 패킷을 다시보내는 동작과 관련이 있어
보통 패킷의 손실이 있을때 재송신을 몇분쯤에 하게되어 있는만큼 몇분정도 기다리고 소켓 말소


### 데이터 송수신 동작 총정리

***
**-접속-**

1. 서버측에서 애플리케이션 동작 - `소켓을 만들고 접속 대기상태`로 만든다
2. 클라이언트는 서버에 액세스 하는 동작이 실행될때 `패킷을 작성하지만 송수신은 아직`
3. 클라이언트의 `소켓이 만들어지면 클라이언트 -> 서버로 접속동작`
(`SYN 을 1로 만들고 윈도우 값`(데이터 송수신 전에 수신->송신으로 통지)도 기록하여 TCP헤더 송신, 암호화된 시퀀스 번호의 초기값있음)
4. 서버에서도 `ACK번호(컨트롤비트 ACK:1)(수신확인용),윈도우 SYN:1 , 시퀀스 초기값`을 기록한 TCP헤더 송신
5. 클라이언트도 수신했다는 의미에서 `ACK 서버로 송신`

***
**-송수신동작-**

6. 클라이언트가 `리퀘스트 메세지를 분할하여 TCP헤더에 시퀀스번호를 기록하여 송신` 
7. 서버에서 `ACK번호와 윈도우값을 클라이언트로 송신`
8. 서버에서 `응답메세지를 분할해 TCP헤더에 시퀀스번호를 기록하여 송신`
9. 클라이언트가 수신했다는 의미의 `ACK번호와 윈도우값 서버로 송신`

***
**-연결 끊기 동작-**

서버가 응답 메세지를 보내면 송수신이 완료되어 연결 끊기 동작 돌입

10. 서버(혹은 클라이언트)에서 `FIN을 1로 만든 TCP헤더가 클라이언트`로
11. 클라이언트에서 `ACK번호와 TCP헤더가 서버`로
12. 클라이언트(혹은 서버) 에서 `FIN을 1로 만든 TCP헤더`로
13. 서버에서 `ACK번호와 TCP헤더가 클라이언트로 송신`
14. `소켓 말소`

***