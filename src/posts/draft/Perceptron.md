---
title: 'Perceptron(퍼셉트론)'
date: '2020-06-11'
category: []
draft: True
---

### 퍼셉트론

퍼셉트론이란? 퍼셉트론은 다수의 신호를 입력받아 하나의 신호를 출력한다.

-   1: 신호가 흐른다
-   0: 신호가 흐르지 않는다.

퍼셉트론을 나타낼때의 원을 node 혹은 뉴런이라고 한다. 입력신호는 뉴런에 보내질때 고유한 w(가중치)가 곱해진다. 가중치가 크다는 것은 그 만큼 그 신호가 더 큰 영향력을 준다는것,

_뉴런은 들어온 값의 총합이 특정 한계(임계값)를 넘어설때 1을 출력한다._

해당식은 `x1*w1 + x2*w2 <= theta`

이때 theta부분을 -b로 바꾼다음 이항을 해주면 좀 더 직관적이고 깔끔해지는데
`x1*w1 + x2*w2 + b<=0` 이런식으로 변하게 된다. 그리고 이때의 **b를 편향**이라고 한다.

> 퍼셉트론의 한계
> XOR을 구현하는데 있어서 한계까 드러난다
> XOR은 두개의 입력이 다를때(x1,x2가 서로 다를때) 1을 리턴한다

우리가 살펴보았던 위의 방법으로는 XOR을 구현하는데 한계가 있다. 왜냐면 입력을 받고 그들의 합과 편향의 합만으로는 직선의 방정식이 나오는데
이는 좌표평면위에서 XOR의 점을 구분하기 부적합하기 때문이다. (참고로 XOR은 서로 대각으로 위치해있다.)

따라서 지금부터 선형과 비선형의 개념이 필요해지고 알아보도록하자.

그래서 나온것이 **다층 퍼셉트론**(퍼셉트론의 층을 쌓음)
즉 단층퍼셉트론으로 비선형 영역을 분리할수 없다는것이지 다층은 가능하다.

| x1  | x2  | s1  | s2  | y   |
| --- | --- | --- | --- | --- |
| 0   | 0   | 1   | 0   | 0   |
| 1   | 0   | 1   | 1   | 1   |
| 0   | 1   | 1   | 1   | 1   |
| 1   | 1   | 0   | 1   | 0   |

위의 표에서 x1,x2 y에만 집중해서 본다면 XOR의 모양을 볼수있다.

이렇게 구성된 모양은

| 입력값 | NAND |     |
| ------ | ---- | --- |
|        |      | XOR |
| 입력값 | OR   |     |

이런 모양을 가지게되고 입력값은 각각 `NAND`와 `OR`에 주어지고`NAND의 출력, OR의 출력값`이 다시 `XOR`로 들어가고 이 값이 위의 표에서 보는 s값이 된다.
그리고 0층,1층,2층으로 구성되어있지만 **가중치는 층 사이사이마다 가지게 되므로 2층 퍼셉트론**이라한다.

다층 퍼셉트론을 사용하면 복잡한 회로 심지어 컴퓨터도 표현할수있는데 이론상 2층 퍼셉트론이면 컴퓨터를 표현할수있다(단 이때 **sigmoid**함수를 이용하면 임의의 함수를 표현할수있다) 하지만 2층으로 만드는건 어렵고 비효율적이므로 필요한 모듈을 차례차례 쌓아서 층층이 겹쳐나간다.

### 👨‍💻 실습코드

```python
import numpy as np
# 퍼셉트론 구현하기
def AND(x1, x2):
    w1, w2, theta = 0.5, 0.5, 0.7
    tmp = x1*w1 + x2*w2
    if tmp <= theta:
        return 0
    else:
        return 1

print(AND(0, 0))
print(AND(1, 0))
print(AND(0, 1))
print(AND(1, 1))

# 편향을 도입한 퍼셉트론 구현하기

def AND2(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w*x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5])
    b = 0.7
    tmp = np.sum(w*x) + b
    if tmp <= 0:
        return 0
    else:
        return 1

def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.2
    tmp = np.sum(w*x) + b

    if tmp <= 0:
        return 0
    else:
        return 1

print(OR(1, 0))
print(AND2(1, 0))

def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND2(s1, s2)
    return y

print("#"*50)
print(XOR(0, 0))
print(XOR(0, 1))
print(XOR(1, 0))
print(XOR(1, 1))

```
